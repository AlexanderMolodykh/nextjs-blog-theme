---
title: Windows Communication Foundation (WCF) reminder
description: ""
date: May 31 2014
---

under construction

## What a WCF is?
WCF is a framework for building service-oriented applications.


## WCF’s ABС
In order to access some WCF service you have to define endpoint which contains such key parameters as: Address, Binding and Contract

**Address** can be defined as IP or host name with port and special path. Different kinds of protocols can be used: HTTP, TCP, NamedPipe, Peer2Peer, MSMQ.
```
http://host:8080
net.tcp://host:987/service
net.pipe//pipe/service
```

**Binding** specifies service access mode.

- Protocols determines the security, reliability, and context flow settings to use for messages that are sent to the endpoint;
- Encoding determines the wire encoding to use for messages that are sent to the endpoint, for example, text/XML, binary, or Message Transmission Optimization Mechanism (MTOM);
- Transport determines the underlying transport protocol to use when sending messages to the endpoint: HTTP, TCP, NamedPipe, Peer2Peer, MSMQ.


Supported bindings and its characteristics are shown [here](http://msdn.microsoft.com/en-us/library/ms730879(v=vs.110).aspx)


**Contract** is a way to describe what service does.
- Service contract describes an operations that service can perform.
- Data Contract defines which data types are passed to and from the service.
- Fault contracts defines errors raised by the service.
- Message contracts contains Data like a DatContract, however, it allows to control the structure of SOAP message, e.g. what data should be in header and what in body, or element names. It also makes some restrictions on operation syntax.  [MessageContract](http://msdn.microsoft.com/en-us/library/ms730255(v=vs.110).aspx)
- Collection data contract allows to control xml representation of collections precisely.

```cs
        [ServiceContract]
        public interface ISomeService
        {
            [OperationContract]
            SomeData SomeOperation(int arg1, string arg2, SomeData arg3);

            [OperationContract]
            SomeMessage SomeOperation(SomeMessage);
        }

        [DataContract]
        public class SomeData
        {
            [DataMember]
            public int SomeId { get; set; }
            [DataMember]
            public List<string> SomeData { get; set; }
        }

        [MessageContract]
        public class SomeMessage
        {
           [MessageHeader(ProtectionLevel=None)] public int arg1;
           [MessageHeader(ProtectionLevel=Sign)] public int arg2;
           [MessageBodyMember(ProtectionLevel=EncryptAndSign)] public string SomeData;
        }

        [CollectionDataContract(
            Name = "CountriesOrRegionsWithCapitals", 
            ItemName = "entry", 
            KeyName = "countryorregion", 
            ValueName = "capital")]
        public class CountriesOrRegionsWithCapitals2 : Dictionary<string, string> { }

```



## Binding

Standart bindings support transport protocols: HTTP, TCP, P2P, Named Pipes, MSMQ.

Purpose of using of **named pipes** is when communication is required between different WCF applications on a single computer, and you want to prevent any communication from another machine.

Encoding could be binary, text or MTOM.

Security could be on transport or message level or without any.

Some binding support sessions and some of them are not.

Some binding support transactions and some of them are not.

The diagram that helps choosing corect binding
!!!!!!!!!!!!!todo


## Fault contract

Fault contract allows making standartized fault messages.

```cs
        [ServiceContract]
        public interface ISomeService
        {
            [OperationContract]
            [FaultContract(typeof(MathFault))]
            SomeData SomeOperation(int arg1, string arg2, SomeData arg3);
        }

        [DataContract]
        public class SomeFault
        {
            [DataMember]
            public string Cause { get; set; }
            [DataMember]
            public string Resolution { get; set; }
        }
```

Now the SomeOperation body can throw exception this way:

```cs
throw new FaultException<SomeFault>(
    new SomeFault { Cause = "Becuse exception ocured", Resolution = "Write better code)."} );
```

And the fault can be handled on the client side using:


catch (FaultException&lt;SomeFault&gt; e).



## Message Patterns in WCF
**Request-Reply Pattern** is a syncronous way of comunication. The client thread sends a request to the service and thread hangs while waiting the serice responce.

**One-Way Message Exchange Pattern** is the of comunication "shoot and forget". Client sends a request without waiting response and doesn't have the result of operation or even the information concerning the exceptions that may occur.

**Duplex or Callback Message Exchange Pattern** is an asyncronous way of comunication. Client sends a request without waiting response but having the result of operation as callback from the server side. IOW it is a Request-Reply Pattern without hanging the client thread.


One-Way pattern can be easily implemented by setting IsOneWay property in your operation contract.

```cs
[OperationContract(IsOneWay = true)]
void LogAction(string action);
```

Duplex pattern is a bit harder. You have to have two interfaces, the service interface and the callback interface. Both operations have to marked as OneWay and a service must know the callback contract interface.

```cs

        [ServiceContract(CallbackContract=typeof(ILoggingServiceCallback))]
        public interface ILoggingService
        {
            [OperationContract(IsOneWay = true)]
            void LogAction(string action);
        }

        public interface ILoggingServiceCallback
        {
            [OperationContract(IsOneWay = true)]
            void LoggingSuccessful(bool someResult);
        }
```

Looks fine, but who will call LoggingSuccessful? From the service operation body (implementation of LogAction method) will be called the LoggingSuccessfull method manually (OperationContext.Current.GetCallbackChannel<ILoggingServiceCallback>().LoggingSuccessful(true);).

On the client side you have to implement ILoggingServiceCallback in order to have an ability to execute some logic when service calls back.

## Sessions
WCF service session used only to identify the client, an can't store some additional data because service must be stateless by definition.

 - Not all the bindings support sessions, so the one that supports has to chosen.

 - The **InstanceContextMode** behavior must be set as "PerSession".

 - The service contract's property **SessionMode** has to be "Allowed" or "Required". If it equals "NotAllowed" the connections that require session will be ignored. In the case of "Required" the session-less connections will be ignored.

In the case of NetTCPBinding and NetNamedPipeBinding, WCF identifies the client by the underlying transport channel. However, the WSHttp uses connection-less http protocol, so in order to identify the client session it adds session id into header.

Operation can be marked as an operation that breaks session. For this purpose OperationContract has the "IsTerminating" property. If it set as True it breaks the session.


